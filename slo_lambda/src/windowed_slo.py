"""
Given SLIs that contain ratios of CloudWatch metrics, writes new metrics that
aggregate over WINDOW_DAYS and calculate the ratios.
"""

from typing import List, Dict, Any
import datetime
import json
import os
import boto3  # type: ignore


# How long in the past should the SLI should be calculated for
WINDOW_DAYS = int(os.environ['WINDOW_DAYS'])
# Namespace of resulting SLI metrics
SLI_NAMESPACE = os.environ['SLI_NAMESPACE']
# Prefix (usually env name) of resulting metrics
SLI_PREFIX = os.environ['SLI_PREFIX']
# JSON-encoded SLI config, generated by Terraform
SLIS = os.environ['SLIS']


def load_balancer_id(arn: str) -> str:
    """
    load_balancer_id returns the ID part of a Load Balancer ARN
    """
    return "/".join(arn.split("/")[-3:])


class Cloudwatch:
    """
    Cloudwatch contains a single Cloudwatch client so we don't have to
    reinitialize it or pass it as an argument everywhere.
    """
    cloudwatch_client = None

    @classmethod
    def client(cls):
        """
        client returns an initialized Cloudwatch client or creates a new one.
        """
        if cls.cloudwatch_client is None:
            cls.cloudwatch_client = boto3.client('cloudwatch')
        return cls.cloudwatch_client


class MetricBase:
    """
    This base class exists to record the subclass names,
    so we can reference them in our Terraform config.
    """

    metric_types: Dict[str, Any] = {}

    def __init_subclass__(cls):
        super().__init_subclass__()
        cls.metric_types[cls.__name__] = cls


class SingleMetric(MetricBase):
    """
    Holds what we need to query a single CloudWatch metric.

    Example in a Terraform SLI:

      numerator = {
        type        = "SingleMetric"
        namespace   = "${var.env_name}/sli"
        metric_name = "InterestingUrisSuccess"
        dimensions = [
          {
            Name  = "Hostname"
            Value = var.env_name == "prod" ? "secure.${var.root_domain}" : "idp.${var.env_name}.${var.root_domain}"
          }
        ]
      }
    """

    def __init__(self, namespace: str, metric_name: str, dimensions: List):
        self.namespace = namespace
        self.metric_name = metric_name
        self.dimensions = dimensions
        self.stat_args = {
            'StartTime': datetime.datetime.utcnow() - datetime.timedelta(days=WINDOW_DAYS),
            'EndTime': datetime.datetime.utcnow(),
            'Period': WINDOW_DAYS * 24 * 60 * 60,
            'Statistics': [
                'Sum',
            ],
        }

    def sum(self) -> float:
        """
        sum returns the sum of a single cloudwatch metric over WINDOW_DAYS
        """
        total = 0.0
        for datapoint in Cloudwatch.client().get_metric_statistics(
                Namespace=self.namespace,
                MetricName=self.metric_name,
                Dimensions=self.dimensions,
                **self.stat_args,
        )['Datapoints']:
            total += self.extract_stat(datapoint)
        return total

    def extract_stat(self, datapoint: Dict) -> float:
        """
        extract_stat takes a Cloudwatch datapoint and returns the numeric value
        """

        return datapoint['Sum']


class CountMetric(SingleMetric):
    """
    Like SingleMetric, but aggreates with SampleCount() instead of Sum().
    Useful for latency metrics.
    """

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.stat_args['Statistics'] = ['SampleCount']

    def extract_stat(self, datapoint: Dict) -> float:
        return datapoint['SampleCount']


class TrimmedCountMetric(SingleMetric):
    """
    Like SingleMetric, but aggreates with TrimmedCount() instead of Sum().
    Useful for latency metrics.
    """

    def __init__(self, threshold: str, **kwargs):
        super().__init__(**kwargs)
        self.threshold_stat = 'TC(:%s)' % threshold
        self.stat_args.pop('Statistics')
        self.stat_args['ExtendedStatistics'] = [self.threshold_stat]

    def extract_stat(self, datapoint: Dict) -> float:
        return datapoint['ExtendedStatistics'][self.threshold_stat]


class LBValidRequestMetric(MetricBase):
    """
    LBValidRequestMetric encompasses all valid requests to the LB, including those that
    return before selecting a target group. Excludes 4XX reponses originiating
    from the LB.

    Example in a Terraform SLI:

      denominator = {
        type        = "LBValidRequestMetric"
        load_balancer_arn = aws_alb.idp.arn
      }
    """

    def __init__(self, load_balancer_arn: str):
        self.lb_name = load_balancer_id(load_balancer_arn)

    def sum(self) -> float:
        self.request_count = SingleMetric(
            namespace='AWS/ApplicationELB',
            metric_name='RequestCount',
            dimensions=[
                {
                    'Name': 'LoadBalancer',
                    'Value': self.lb_name,
                }
            ]
        )

        self.elb_500s = SingleMetric(
            namespace='AWS/ApplicationELB',
            metric_name='HTTPCode_ELB_5XX_Count',
            dimensions=[
                {
                    'Name': 'LoadBalancer',
                    'Value': self.lb_name,
                }
            ]
        )
        return self.request_count.sum() + self.elb_500s.sum()


class LBGoodResponseMetric(MetricBase):
    """
    LBGoodResponseMetric encompasses all good reponses from the target group. Excludes
    5XX responses and timeouts.

    Example in a Terraform SLI:

      numerator = {
        type        = "LBGoodResponseMetric"
        load_balancer_arn = aws_alb.idp.arn
      }

    """

    def __init__(self, load_balancer_arn: str):
        self.lb_name = load_balancer_id(load_balancer_arn)

    def sum(self) -> float:
        responses = [
            SingleMetric(
                namespace='AWS/ApplicationELB',
                metric_name='HTTPCode_Target_2XX_Count',
                dimensions=[
                    {
                            'Name': 'LoadBalancer',
                            'Value': self.lb_name,
                    }
                ]
            ),
            SingleMetric(
                namespace='AWS/ApplicationELB',
                metric_name='HTTPCode_Target_3XX_Count',
                dimensions=[
                    {
                        'Name': 'LoadBalancer',
                        'Value': self.lb_name,
                    }
                ]
            ),
            SingleMetric(
                namespace='AWS/ApplicationELB',
                metric_name='HTTPCode_Target_4XX_Count',
                dimensions=[
                    {
                        'Name': 'LoadBalancer',
                        'Value': self.lb_name,
                    }
                ]
            ),
        ]
        return sum([x.sum() for x in responses])


class SLI:
    """
    SLI calculates an SLI definition as a ratio of good requests to
    total requests.

    Please note that we assume `numerator` and `denominator` were defined in
    Terraform, and parsed as JSON. So they should be Dicts, not Metrics.

    Example:

    interesting_availability = {
      numerator = {
        type        = "SingleMetric"
        namespace   = "foo_env/sli"
        metric_name = "InterestingUrisSuccess"
        dimensions = [
          {
            Name  = "Hostname"
            Value = "foo"
          }
        ]
      }
      ...
    }
    """

    def __init__(self, numerator: Dict, denominator: Dict):
        # numerator and denominator were defined as dictionaries. Convert them
        # to Metric objects.
        num_args = {k: v for (k, v) in numerator.items() if k != "type"}
        num = MetricBase.metric_types[numerator['type']](**num_args)
        self.num = num

        denom_args = {k: v for (k, v) in denominator.items() if k != "type"}
        denom = MetricBase.metric_types[denominator['type']](**denom_args)
        self.denom = denom

    def get_ratio(self) -> float:
        """
        get_ratio returns the sum of the numerator diveded by the sum of the
        denominator, calculated over the last WINDOW_DAYS.

        Can return ZeroDivisonError.
        """
        numerator = self.num.sum()
        denominator = self.denom.sum()

        return numerator / denominator


def create_slis(slis: Dict[str, SLI]):
    """
    create_slis takes a dictionary of SLIs, gets their values and writes the
    associated Cloudwatch metrics.
    """
    for sli_name, sli in slis.items():
        try:
            value = sli.get_ratio()
        except ZeroDivisionError:
            print("x/0 error for %s" % sli_name)
            continue
        print("%s: %f" % (sli_name, value))
        metric_data = [
            {
                'MetricName': SLI_PREFIX + "-" + sli_name,
                'Value': value,
            }
        ]
        Cloudwatch.client().put_metric_data(
            Namespace=SLI_NAMESPACE,
            MetricData=metric_data,
        )


def parse_sli_json(sli_json: str) -> Dict[str, SLI]:
    """
    parse_sli_json takes JSON (usually generated by Terraform), initializes
    SLI objects from the resulting dictionaries, and returns a dictionary of
    SLI definitions.
    """

    sli_configs = json.loads(sli_json)
    slis = {}
    # Since the SLIs were defined in Terraform and converted to JSON
    # dictionaries, we need to convert them to SLI objects.
    for sli_name, sli_config in sli_configs.items():
        sli = SLI(**sli_config)
        slis[sli_name] = sli
    return slis


def lambda_handler(event, context):
    # Parse SLIs
    slis = parse_sli_json(SLIS)
    # Write SLI metrics from the SLI definitions
    create_slis(slis)


def main():
    lambda_handler(None, None)


if __name__ == '__main__':
    main()
